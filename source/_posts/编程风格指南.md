---
title: 编程风格
top: false
cover: false
toc: true
mathjax: true
date: 2020-08-30 12:46:17
password:
summary:
tags:
- Law
- 软件工程
categories:
- 软件工程
---

# 编程风格

2021.5.15更新：参考《.Net 设计规范》制定了编码风格。

# C#

### 类成员的设计

##### 私有字段名

camelCasting命名法

``` c#
private int myHealth = 1;
```

#####  公/私有函数名，公/私有属性名（一般不私有），公有字段名（不要提供公有或受保护的字段，考虑属性）

PascalCasting命名法，函数名务必是动词

```c#
public int Init() { MyHealth = 1; }
```

##### 临时变量/函数参数

camelCasting命名法

```c#
public int Excute(string actionName){
    var actionId = GetIdByName(actionName);
    Run(actionId);
    return actionId;
}
```

##### 常量

PascalCasting命名法

```c#
const int MaxHealth = 10;
```

除此之外，还需注意几个原则：

- 不要缩写（除非你能在Google上用缩写查到这个词的意思如Id，UI，IO，SOS），缩写要么全大写要么全小写（Id为特例）
- 不要把复合词语写成多个单词
- 可读性高于简洁性
- 不要用一般化名来命名如Element、Node、Item类、结构、命名空间，要加上限定符
- 不要使用匈牙利命名法
- List等集合形式后面加上`s`表示复数即可
- 优先使用Collection而不是数组（或者枚举器），不要使用只读数组，使用只读集合
- 要用肯定性短语：Is、Can、Has（前缀如无必要则不要加）

##### 函数

###### 参数设计

- 先弄明白需求，选择最简单但能满足需求的参数
- 优先使用枚举而不是布尔值
- 要抛出Argument Exception
- 不要用Enum.IsDefine来检查枚举值
- 避免使用out和ref
- 尽量不使用params

###### 重载

- 优先提供重载而不是默认参数
- 较短的重载应该调用较长的重载
- 只把最长的重载设置为虚方法
- 不要定义参数类型相似但不同语义的重载

###### 函数与属性

- 优先使用属性赋值而不是方法，方法应该表示操作，而属性才表示数据
- 除非有性能问题，否则你应该优先使用属性
- 如果一个属性每次都返回不同结构，那么他应该是一个方法（DateTime.Now应该设计为方法）
- 属性只用来做一些简单运算，否则使用方法
- 不要提供只写属性，也不要让getter比setter访问范围更广，否则用方法
- 为所有属性提供合理的默认值
- 避免在getter抛出异常，否则使用方法

###### 构造函数

- 在构造函数里做最小的事情，属性应该和构造函数参数列表一致
- 避免在Struct中显式定义默认构造函数
- 考虑在Class中显示定义默认构造函数
- 避免在构造函数中调用虚方法
- 考虑以内联的形式初始化静态字段

###### 扩展方法

- 不要草率定义扩展方法，先用实例方法
- 考虑使用扩展方法来解耦
- 对接口使用，扩大使用范围

### 类、结构、接口、枚举等数据结构的设计

- PascalCasting命名法
- 一般是名词或名词短语，如果无法提供这类单词，你可能要考虑重新设计。
- 不要添加前缀，除了接口
- 考虑在派生类的末尾使用基类的名字，如Exception、EventArgs
- 要确保一对类/接口只相差一个`I`前缀，如果该类是该接口的标准实现
- 泛型参数，用T或T后面加描述
- 优先使用抽象类而不是接口（便于之后增加新的成员，提供兼容性）
- 继承接口是Can-Do的关系，而类继承是Is-a的关系
- 要为抽象类提供至少一个具体实现
- 尽量少用静态类，不要将他作为杂物箱，要有明确的定义
- 不要定义没有成员的接口，考虑修饰属性（Attribute）
- 不要定义可变值类型，要为值类型实现IEquatable和重载`==` `!=`运算符

##### 枚举

- 使用单数名词
- 复数名词表示位域
- 不要添加前后缀
- 不要比较枚举的Sentinel值
- 为简单枚举提供零值

##### 标记枚举（flag）

- 不要为简单枚举提供标记枚举
- 考虑为常用标记组合提供特殊枚举值（复合枚举）
- 将0标记为None

##### 扩展性设计

- 把protected成员和public成员看成是一样的，只在完成高级功能时用protected
- 优先考虑事件而不是委托，避免在性能要求很高的API中使用委托
- 不要提供抽象，除非该抽象以及被实现并测试过了
- 提供一个接口和继承自该接口的抽象类
- 只有为框架的使用者提供显著帮助时才使用基类，如果只是为了方便实现，则不要用

### 事件的设计

参考https://blog.csdn.net/FliesOfTime/article/details/100688367

事件始终是指某个操作，这个操作可能正在发生，也可能已经发生。 因此与方法一样，事件用谓词命名，谓词时态用于指示事件引发的时间。

**✓ 务必**使用谓词或谓词短语来命名事件。

示例：`Clicked`、`Painting`、`DroppedDown` 等。

**✓ 务必**通过使用现在时态和过去时态，让事件名称含有时间先后的概念。

例如，窗口关闭之前引发的事件称为 `Closing`，窗口关闭之后引发的事件称为 `Closed`。

X 请勿使用 “Before” 或 “After” 前缀和后缀来指示事件之前或之后。 应按前述使用现在时态和过去时态。

**✓ 请使用 “EventHandler” 后缀来命名事件处理程序（用作事件类型的委托）**，如以下示例所示：

```
public delegate void ClickedEventHandler(object sender, ClickedEventArgs e);
```

**✓ 务必**在事件处理程序中使用两个名为 `sender` 和 `e` 的参数。

sender 参数表示引发事件的对象。 sender 参数的类型通常是 `object`，且可能会使用更具体的类型。

**✓ 务必**使用“EventArgs”后缀来命名事件参数类。

***个人建议：对于名称意义不明的事件可添加Event后缀，尽量少用后缀。***

官方参考：https://docs.microsoft.com/zh-cn/dotnet/standard/design-guidelines/names-of-type-members#names-of-events

##### 事件触发方法的名称

事件需要有一个事件触发方法，用于检测事件是否有绑定的方法，如果有就触发事件。直接触发事件在事件没有绑定方法时会引发空异常。

**✓ 务必**使用“On+事件名称”来命名事件触发方法。

### 异常的设计

- 应该统一使用异常而不是返回值来显示错误（比如错误码）
- 异常指的是操作失败，而不是异常情况
- 不习惯异常语法不是你不使用异常的理由
- 要为所有异常编写文档
- 要使用最合理最底层的异常
- 不要把异常吞了，考虑捕获特定类型的异常，不要捕获一般异常或系统异常（Exception、SystemException）
- 尝试用Tester-Doer模式或者Try-Parse模式，先检查再使用，以提高异常性能

##### 消息设计

- 用句号而不要用问号以及感叹号，避免语法错误